{"name":"Python-study","tagline":"python study","body":"#python\r\n개인적으로 공부한 내용을 바탕으로 작성한 문서입니다.([참고한곳](https://docs.python.org/2/contents.html))\r\n\r\n내용은 파이썬에 대한 여러가지 잡다한 설명과 코드가 될것같네요.\r\n\r\npython 2를 기준으로 설명하고, 어느정도 파이썬에 대해 지식이 있는 사람을 대상으로 해요.\r\n\r\n전부 설명하는건 아니고 그냥 제가 보기에 쓸만한것만 설명합니다.\r\n\r\n(\"꽝, 다음기회에\" 라 써져있는부분은 아직 작성하지 않은 부분입니다)\r\n\r\n\r\n##python2 vs python3\r\n파이썬3이 나온건 2008년인데요, 아직까지 파이썬2가 쓰이는 이유는 참 많습니다.\r\n\r\n- 지원 라이브러리 많음\r\n- python2의 지원기간의 연장\r\n- python3의 기능들 몇몇이 python2로 내려옴\r\n\r\n특히 python2의 지원기간 연장은 충격적이였는데요, 원래 2014년을 끝으로 지원이 끝날 예정이였으나([참고](https://hg.python.org/peps/rev/76d43e52d978))이게 2020년까지 연장이 되었습니다.\r\n다만 python 2.8은 나오지 않는다고 했기때문에 기능추가보단 버그수정이 주가 될것 같습니다. ([참고](https://www.python.org/dev/peps/pep-0404/#id10))\r\n참고로 현재 최신버전은 2.7.9입니다.\r\n\r\n파이썬 2와 3의 기능적 차이점은 여러가지가 있지만 이정도만 아시면 될것같습니다\r\n\r\n- python2가 unicode가 str처럼 작동\r\n- print의 함수화\r\n- long 삭제(전부 int로 처리)\r\n- 나눗셈(/) 가 항상 float를 리턴\r\n- python2의 raw_input이 3의 input이 됨\r\n\r\n여기서 long의 삭제는 숫자연산이 많은 프로그램의 성능을 악화(약간)시키는 원인이 되기도 했습니다.\r\n\r\n이것외에도 많은 차이가 있는데 자세한건 검색을...\r\n\r\n##pip 설치\r\nhttps://bootstrap.pypa.io/get-pip.py 를 받아서 커맨드창이나 콘솔에서 실행하면 되요.\r\n\r\n윈도우 유져이고, 사용자명에 한글이 들어가는 경우 안될수 있는데 이럴때에는 TEMP와 TMP 환경변수를 한글이 없는 적당한 폴더로 설정하시면 잘 됩니다.\r\n\r\n##소스코드 인코딩\r\n```python\r\n# -*- coding: encoding -*-\r\n# -*- coding: utf-8 -*-\r\n```\r\n코드내에 한글이 있으면 꼭 써줘야 해요.\r\n\r\n\r\n##제어문\r\n```python\r\nfor some in iterable_something:\r\n\t#do something\r\n\r\nfor some1,some2 in iterable_something:\r\n\t#do something\r\n\r\nif something:\r\n\t#do  something\r\n\r\nwhile something:\r\n\t#do something\r\nelse:\r\n\t#do something\r\n\r\n```\r\nbreak는 for,while에서 사용 가능해요.\r\n\r\n반복문 내에서 호출된 함수내부에서는 사용 불가능(문법상의 문제)\r\n\r\ncontinue는 그 이후 코드를 실행하지 않고 바로 다음 루프로 이동\r\n\r\n##함수\r\n```python\r\ndef test(arg1,arg2,arg3=3):\r\n\t#do something with arg1,arg2,arg3....\r\n\r\ntest(arg1,arg2) #arg3에는 3이 들어감,기본값 지정이 된 인자는 생략 가능\r\ntest(arg2=some1, arg1=some2) #인자명을 지정해서 써줄수 있음\r\n\r\ndef bad_test(arg1=[]):#안좋은 방식\r\n\targ1.append(1)\r\n\tprint arg1\r\n\r\ntest()#[1]\r\ntest()#[1,1]\r\ntest()#[1,1,1]\r\n\r\ndef good_test(arg1=None):#좋은 방식\r\n\tif arg1==None:\r\n    \targ1=[]\r\n\targ1.append(1)\r\n    print arg1\r\n\r\ndef test(*l):\r\n\tprint type(l),l\r\ntest(1,2,3)#<type 'tuple'> (1, 2, 3)\r\n\r\ndef test(**d):\r\n\tprint type(d),d\r\ntest(a=1,b=2)#<type 'dict'> {'a': 1, 'b': 2}\r\n\r\ndef test():\r\n\t'''이건 함수 설명 문자열이에요'''\r\n\tpass\r\ntest.__doc__#'이건 함수 설명 문자열이에요'\r\n```\r\n\r\n##색다른 함수호출방법\r\n```python\r\nd=[1,10,3]\r\nrange(d)#error\r\nrange(*d)#[1, 3, 5, 7, 9] =range(1,10,3)\r\n\r\nd={}\r\nd['arg1']=1\r\nd['arg2']=2\r\nsome_function(*d)#== some_function(arg1=1,arg2=2)\r\n```\r\n##list\r\n\r\n###method\r\n\r\n- append(v)\r\n \r\n 리스트 마지막에 추가한다.\r\n  \r\n- index(v[,start[,stop]])\r\n\r\n start부터 stop사이에 v를 찾아서 첫번째 위치를 리턴.\r\n 발견 못할시 ValueError 예외가 일어남.\r\n\r\n- remove(v)\r\n \r\n v를 '한'개 지움\r\n \r\n- sort(cmp=None, key=None, reverse=False)\r\n\r\n 내부적으로는 sorted함수 사용\r\n \r\n l.sort() -> l=sorted(l)\r\n \r\n cmp와 key인자로 커스텀화 가능\r\n\r\n```python\r\nl=[[1,2],[2,1],[9,4],[5,5]]\r\nl.sort(key=lambda x:x[1]) #x[1]을 비교하는 키로 사용\r\n#[[2, 1], [1, 2], [9, 4], [5, 5]]\r\n\r\nl.sort(cmp=lambda x,y:cmp(x[1],y[1]))#비교함수를 설정함, 인자는 2개 받고 리턴값은 1,0,-1\r\n#[[2, 1], [1, 2], [9, 4], [5, 5]]\r\n```\r\n\r\n##tuple\r\n수정안되는 list같은거\r\n\r\n길이가 1짜리 tuple만드는법(가끔 tuple형만을 원하는 함수가 있음 ex. sqlite3의 execute함수)\r\n\r\n```python\r\nt=1,\r\nt=(1,)\r\n```\r\n\r\n##set\r\n집합\r\n\r\n가장 큰 특징으로는 중복이 안된다는것\r\n\r\n```python\r\na=set([1,2])\r\nb=seet([2,3])\r\na-b# 1\r\na+b# error\r\na&b# 2\r\na|b# 1,2,3\r\n\r\na.add(1)#1,2 에러가 나질 않는다!\r\na.add(3)#1,2,3\r\n```\r\n\r\n##dictionary\r\nkey-value 구조를 가지고 있고 순서가 없는 데이터형\r\n\r\n잘쓰면 편함\r\n\r\n```python\r\na={}\r\nb={1:1,'1':'1'}\r\na[1]=1\r\na['1']='1'\r\n```\r\n\r\n###method\r\n- items()\r\n\r\n (key,value)형태를 가진 리스트 리턴\r\n\r\n- iteritems\r\n\r\n items()의 itemiterator 버전\r\n \r\n- values(),keys()\r\n \r\n 각각 value만,key만 리스트로 리턴\r\n\r\n##import\r\n```python\r\nimport test\r\n#같은 폴더의 test.py나 test.pyc 가 존재하면 임포트\r\n#test가 폴더면 그 안에있는 __init__.py를 임포트\r\n#그 외에는 sys.path 에서 임포트 site-package라든가 libs라든가 등등..\r\n#자기자신도 임포트 가능... 어디다 쓰지?\r\n\r\nimport test as t # test를 이름 t로 임포트\r\nfrom test import test #test.py에서 test란것을 임포트\r\nfrom test import * #test.py에서 모든걸 임포트 별로 않좋은 방식\r\nfrom test.test1 import test2 #test폴더에서 test1폴더에 있는 test2를 임포트\r\n```\r\n\r\n참고로 \\_\\_all\\_\\_=[a,b,c]가 있다면 import \\* 해도 a,b,c만 임포트가 됨\r\n\r\n패키지에서는 이런식의 import도 가능하다.\r\n```python\r\nfrom . import at_same_folder\r\nfrom .. import at_parents_folder\r\nfrom ..at_parents_folder import my_parents_another_son\r\n```\r\n[여길](https://docs.python.org/2/tutorial/modules.html#intra-package-references]) 참고하자\r\n\r\n##문자열과 %\r\nC언어의 printf와 거의 비슷한 사용법을 가진다\r\n```python\r\na='test %s'%'hehe'#test hehe\r\na='%s %s'%('test','hehe')#test hehe\r\n```\r\n특이한 포맷은 %r 이 있는데 이건 repr(v)한 결과를 문자열로 붙여놓는다\r\n\r\n##예외\r\n예외처리는 다음과 같이 한다\r\n```python\r\ntry:\r\n\t#do something\r\n\r\nexcept except_name_1 , e:\r\n\tprint e\r\n\r\nexcept except_name_2 , e:\r\n\tprint e\r\n\r\nelse:\r\n\t#do something\r\n\r\nfinally:\r\n\t#do something\r\n```\r\nexcept는 예외가 일어났을때 실행되고, finally가 있을경우 생략 가능하다(???????)\r\n\r\nelse는 예외가 안일어났을경우 실행되고, 생략 가능하다\r\n\r\nfinally는 예외가 있든없든 항상 실행되고, 생략 가능하다.\r\n\r\n예외의 이름과 e라 되어있는 부분도 생략 가능하다.\r\n\r\ne라 되어있는건 예외에 대한 정보를 담는 변수가 된다. 이건 그냥 print하면 'name 'ab' is not defined' 이런식으로 간단한 정보만 나온다. 좀더 자세한 예외 정보를 원한다면 라이브러리를 써야한다.\r\n\r\nidle에서 보는 형태의 예외정보를 보려면 간단하게 다음처럼 하면 된다(완전히 같진 않음)\r\n\r\n```python\r\nimport traceback\r\ntry:\r\n\tnoname()\r\nexcept:\r\n\ttraceback.print_exc()\r\n```\r\n또는 logging을 쓰는 방법도 있다.\r\n```python\r\nimport logging\r\ntry:\r\n\tnoname()\r\nexcept:\r\n\tlogging.exception('except!!!')\r\n```\r\n\r\n예외를 강제로 일으키려면 raise 를 쓰면 된다\r\n```python\r\nraise TypeError\r\n```\r\n\r\n위에서 언급했던 try...finally처럼 예외에서는 좀 특이한 동작이 몇가지 있다\r\n\r\n```python\r\ndef life():\r\n\ttry:\r\n    \treturn 42\r\n\tfinally:\r\n    \treturn 'egg'\r\n```\r\nlife의 리턴값은 뭘까?\r\n\r\n궁금하면 [여길](https://docs.python.org/2/reference/compound_stmts.html#the-try-statement) 참고하자\r\n\t\r\n##class\r\n꽝. 다음기회에\r\n\r\n##keyword\r\n- and\r\n- del\r\n- from\r\n- not\r\n- while\r\n- as\r\n- elif\r\n- global\r\n- or\r\n- with\r\n \r\n with A() as a: 와 같은 형태로 쓰인다(with A() as a, B() as b: 도 가능)\r\n \r\n 특징은 이 구문이 끝남과 동시에 a가 사라진다는 것이다.\r\n 그래서 with open('test','r\") as f 와 같이 많이 쓰인다\r\n \r\n- assert\r\n- pass\r\n- yield\r\n- break\r\n- exec\r\n- is\r\n- lambda\r\n\r\n##built-in function\r\n- abs(v)\r\n\r\n v의 절대값 리턴\r\n\r\n- all(iter)\r\n\r\n iter의 값을 v라 했을때 모든 v에 대해 bool(v)가 True면 True리턴, 그외에는 전부 False\r\n \r\n- any(iter)\r\n\r\n iter의 값을 v라 했을때 모든 v에 대해 bool(v)가 False면 False리턴, 그외에는 전부 True\r\n\r\n```python\r\nall([1,True,None])#False\r\nany([1,True,None])#True\r\n```\r\n\r\n- bytearray\r\n- chr(v)\r\n\r\n v를 ascii에 해당하는 문자열로 변경.\r\n \r\n 그래서 v는 항상 0xff이하이다.\r\n\r\n- dir(v)\r\n\r\n 개인적으로 애용하는 함수.\r\n \r\n v.?의 ?에 올수있는것들을 리스트로 전부 출력한다.\r\n \r\n 만약 v.__dir__함수가 존재하면 그 함수를 실행시킨다.\r\n \r\n dir()은 네임스페이스를 출력한다.\r\n\r\n- enumerate(iter)\r\n\r\n ```python\r\n l=['a','b','c']\r\n for n,c in enumerate(l):\r\n \tprint n,c\r\n #0,a\r\n #1,b\r\n #2,c\r\n ```\r\n\r\n- eval\r\n \r\n 꽝, 다음기회에\r\n\r\n- file(name[, mode[, buffering]]) 그리고 open(name[, mode[, buffering]])\r\n\r\n file은 type을 상속받은 class다.\r\n \r\n open은 함수다.\r\n \r\n 그래서 다음과 같은 차이가 발생한다\r\n \r\n ```python\r\n isinstance(f,file)#ok\r\n isinstance(f,open)#error\r\n ```\r\n\r\n- filter(function, iter)\r\n\r\n iter의 각 요소를 function에 인자로 넘겨서 True일경우 리스트에 추가해서 리턴한다\r\n ```python\r\n filter(lambda x:x%2,[1,2,3,4,5])#[1, 3, 5]\r\n ```\r\n\r\n- hash(v)\r\n\r\n 안전한 해쉬함수가 아니니 절대 비밀번호 비교용으로 쓰지 말자\r\n\r\n- help(v)\r\n \r\n \\_\\_doc\\_\\_을 읽어와 자동으로 help문서를 작성해서 출력해준다\r\n\r\n- id(v)\r\n\r\n v의 고유한 id를 출력한다.\r\n \r\n 참고로 id의 리턴값은 해당 v의 메모리 주소다.(cpython기준) 그래서 리스트같은건 같은값을 가지더라도 같은id를 가지지 않을 수 있다.\r\n\r\n- input(s)\r\n\r\n python2에서는 eval(raw_input(s)) 와 같다\r\n \r\n python3에서는 python2의 raw_input과 같다\r\n\r\n- int(v,base)\r\n \r\n 문자열을 int로 바꾼다. base에는 진수가 들어간다.\r\n ```python\r\n int('abc',16)#2748\r\n ```\r\n\r\n- isinstance(v,classinfo)\r\n\r\n v가 classinfo와 같은지 체크한다. classinfo에는 한개의 class나 여러개의 class가 튜플로 들어간다\r\n ```python\r\n isinstance(v,(unicode,str))#v가 유니코드거나 문자열이면 True\r\n ```\r\n\r\n- map(func,iter)\r\n\r\n iter에서 하나씩 가져와서 func에 인자로 넘겨주고 그걸 다시 리스트로 만들어낸다. 예제를 보자\r\n ```python\r\n a1=raw_input()#hello 입력\r\n a2=map(ord,a1)\r\n print a1#hello\r\n print a2#[104, 101, 108, 108, 111]\r\n ```\r\n 잘쓰면 짱짱이다.\r\n\r\n- max(iter)\r\n\r\n iter중 최대값을 리턴한다.\r\n\r\n- min(iter)\r\n\r\n iter중 최대값을 리턴한다.\r\n\r\n- ord(v)\r\n\r\n 한글자를 받아서 ascii값을 리턴한다.\r\n\r\n- print(\\*objects, sep=' ', end='\\n', file=sys.stdout)\r\n\r\n 프린트한다. sep은 print(1,2,3)이렇게 호출했을때 1,2,3사이에 들어갈 문자열이다 \r\n\r\n- exit,quit\r\n\r\n id값은 다르지만 같다\r\n\r\n- range(start, stop[, step])\r\n\r\n start부터 stop까지 step만큼 건너뛰면서 리스트를 만든다\r\n ```python\r\n range(1,10,3)#[1, 4, 7]\r\n ```\r\n 동작 방식이 리스트를 만들고 리턴하는것이기 때문에 stop이 커지면 비효율적이다.\r\n \r\n 가급적 xrange를 사용하자.(인자 같음)\r\n\r\n- reload(m)\r\n\r\n 이미 한번 로드된 모듈을 다시 로드한다. 개발중에 유용함.\r\n\r\n- super\r\n\r\n 꽝, 다음기회에\r\n\r\n- unichr(v)\r\n\r\n chr과 비슷한 함수인데 다만 리턴이 유니코드다. 또한 v의 값 역시 0x10000까지다\r\n\r\n- unicode\r\n\r\n 한글관련 문제가 생길때 무조건 쓰게되는 함수\r\n \r\n 별로 좋지 않은 코드지만 귀찮으면 이렇게 하면된다.\r\n \r\n ```python\r\n my_unicode(some_str)\r\n try:\r\n \treturn unicode(some_str,'utf-8')\r\n except:\r\n \treturn unicode(some_str,'euc-kr')\r\n ```\r\n \r\n 참고로 some_str은 str이여야한다. unicode면 둘다 에러남\r\n\r\n- xrange\r\n\r\n range에서 설명한 그것.\r\n for문에서는 가급적 이걸쓰자\r\n\r\n- zip\r\n\r\n 2개 이상의 iterable한 애들을 묶어주는 함수다. for문같은 곳에서 유용하다.\r\n ```python\r\n l1=[1,2,3]\r\n l2=[4,5,6]\r\n l=zip(l1,l2)#[(1, 4), (2, 5), (3, 6)]\r\n for v1,v2 in zip(l1,l2):\r\n \t#do something...\r\n ```\r\n\r\n##file\r\n파일입출력을 담당하는 클래스\r\n\r\n기본적인 내용은 pass\r\n\r\nreadlines() 는 파일 전부를 한번에 읽어서 리스트로 만드는데, 메모리 효율상 별로 좋진 않다.\r\n\r\n그래서 만들어진게 xreadlines(). 한번에 파일을 읽지 않고 필요할때마다 파일을 읽어 리턴한다.\r\n\r\n하지만 이 함수들보단 이렇게 쓰는게 가독성면에서 좋다고 생각한다\r\n```python\r\nwith open('README.md','r') as f:\r\n\tfor line in f:\r\n    \tprint line\r\n```\r\n캬\r\n\r\n방금 [어디](http://soooprmx.com/wp/archives/4940)선가 이방법은 메모리에 한번에 올린다고 써놨다.\r\n\r\n테스트가 필요할\r\n\r\n#문자열 관련 모듈들\r\n\r\n##import string\r\n나중에\r\n\r\n\r\n##import re\r\n어떤 특정한 문자와 문자 사이의 값을 뽑아내고 싶을때\r\n\r\nex)`<span id=\"sadfdsaf\">{{여길뽑아내고싶다}}</span>`\r\n\r\n```python\r\nimport re\r\na=re.findall('<span id=\"sadfdsaf\">?(.*?)</span>',docu,re.DOTALL)\r\n```\r\n이러면 a에 뽑힌 리스트가 들어가있다.(정규식은 잘 몰라서 별로 좋지 못한 코드일 가능성이 높음)\r\n\r\n\r\n아직 작성할거 남음\r\n\r\n##import struct\r\npack과 unpack때문에 존재하는 모듈\r\n\r\n포맷팅 문자열은 [여기](https://docs.python.org/2/library/struct.html#format-characters)를 참고하면 된다.\r\n\r\n대충 이런식으로 쓰인다.\r\n\r\n```python\r\nimport struct\r\nwith open('test.exe','rb') as f:\r\n\tfmtl=struct.calcsize('2s29HI')\r\n\tfr=f.read(fmtl)\r\n    pe_dos_header=struct.unpack('2s29HI',fr)\r\n    #do something....\r\n```\r\nclacsize는 포맷팅 문자열을 받아서 길이가 몇인지 리턴해주는 함수이다.\r\n\r\n##import difflib\r\n꽝, 다음기회에\r\n\r\n##import StringIO\r\n문자열을 파일이나 버퍼처럼 read()나 write()로 읽고 쓸수 있게 해주는 모듈이다. 처음엔 어디에 쓰이나 싶었던 모듈.\r\n```python\r\nimport StringIO\r\nimport sys\r\nmy_stringio=StringIO.StringIO()\r\nsys.stdout=my_stringio\r\nprint '어쩌구저쩌구'#화면에 출력이 되지않고 my_stringio에 들어가있다\r\n```\r\n또는 flask같은곳에서도 쓰일수있다.\r\n```python\r\n#import 생략\r\nret=StringIO.StringIO()\r\n#do something....\r\nret.write('<br>블라블라...')\r\n#do somethging....\r\nret.write('<div>블라블라...')\r\n#do something...\r\nreturn ret.getvalue()\r\n```\r\n참고로 StringIO는 순수파이썬이고, C로 만들어진 cStringIO가 있는데 살짝 빠르다고 하다.\r\n\r\n##import textwarp\r\n꽝, 다음기회에\r\n\r\n##import codecs\r\n꽝, 다음기회에\r\n\r\n이 모듈을 쓰는일이 없었으면 좋겠다...\r\n\r\n재밌는 인코딩이 있어서 소개한다(임포트 필요 ㄴㄴ)\r\n\r\n```python\r\nprint 'anch0vy'.encode('rot13')#napu0il\r\nprint '멸치'.encode('base64')#uOrEoQ==\r\nprint u'멸치'.encode('idna')#xn-- -6ba4rxa87z\r\nprint '멸치'.encode('bz2')#bz2는 압축의 종류중 하나다.\r\nprint '멸치'.encode('zip')#zip은 압축의 종류중 하나다.\r\n```\r\n마지막 2개 인코딩은 아무런 임포트 없이 압축이 가능하다는 점에서 좋은것같다.\r\n\r\n##import unicodedata\r\n생략\r\n\r\n##import stringprep\r\n생략\r\n\r\n##import fpformat\r\n생략, python3에서 사라짐..\r\n\r\n#데이터 타입 관련 모듈들\r\n\r\n##import datetime\r\n날자 관련 모듈. 요일구하거나 날자계산할때 겁나편하다.\r\n\r\n```python\r\nimport datetime\r\nd=datetime.date(2014,12,31)\r\nprint d.weekday()#월:0 ~ 일:6\r\noneday=datetime.timedelta(days=1)\r\nbefore_one_hundred_day=d-oneday*100\r\nprint before_one_hundred_day.strftime('%y.%m.%d')#14.09.22\r\n```\r\n자세한건 [여기](https://docs.python.org/2/library/datetime.html)\r\n\r\n##import calendar\r\n달력 출력하는 모듈.\r\n\r\n파이썬에서 달력출력할일이 뭐가있지???\r\n\r\n생각보다 모듈사용법이 복잡해보인다\r\n\r\n```python\r\nimport calendar\r\nc = calendar.TextCalendar(calendar.SUNDAY)\r\nc.prmonth(2015, 1)\r\n```\r\n출력은\r\n```\r\n    January 2015\r\nSu Mo Tu We Th Fr Sa\r\n             1  2  3\r\n 4  5  6  7  8  9 10\r\n11 12 13 14 15 16 17\r\n18 19 20 21 22 23 24\r\n25 26 27 28 29 30 31\r\n```\r\n##import collections\r\n영어 설명으로는 High-performance container datatypes 라 되어있는 모듈.\r\n\r\n간단하게 설명하자면 좋은 데이터타입을 모아둔 모듈이다.\r\n\r\n###counter\r\n```python\r\nimport collections\r\nc=collections.counter()\r\nfor word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:\r\n\tcnt[word] += 1\r\nprint cnt # Counter({'blue': 3, 'red': 2, 'green': 1})\r\n```\r\n###deque\r\n나중에\r\n\r\n###OrderedDict\r\n순서가 존재하는 딕셔너리\r\n\r\n##import headq\r\n꽝, 다음기회에\r\n\r\n속도가 빠르다는 소리를 들어서 테스트해보니 확실히 sort보단 빠르다\r\n\r\n##import bisect\r\n나중에\r\n\r\n##import array\r\n\r\nEfficient arrays of numeric values\r\n\r\nlist랑 어떻게 틀린지 아직 모르겠다\r\n\r\n##import sched\r\n간단한 스케쥴관련 모듈인데 별로인듯\r\n\r\n##import Queue\r\n멀티쓰레딩에서 쓰이는 그 큐에 관련된 모듈\r\n\r\n근데 파이썬은 멀티쓰레딩이...\r\n\r\n대신 멀티프로세스를 사용하자. (import multiprocessing)\r\n\r\n##import weakref\r\n 클래스 작성후 작성\r\n \r\n##import UserDict\r\n생략\r\n\r\n##import types\r\n어떤 함수가 있는 모듈은 아니고 타입들이 모여있는 함수다.\r\n\r\ntype검사를 할때 쓰이는걸 한번 본적이 있고, 파이썬의 CodeType을 만들기 위해 써본적이 있다.\r\n\r\n사실 타입검사는 꼼수를 쓰면 이모듈을 안써도 되서...\r\n\r\n```python\r\nimport types\r\ndef test(v):\r\n\tif type(v)==types.TupleType:\r\n    \tprint 'tuple!'\r\n\t#또는(꼼수)\r\n    elif type(v)==type([]):\r\n    \tprint 'list!'\r\n```\r\n참고로 types에 있는 타입들은 클래스라서 이걸로 원래는 만들지 못하는 타입의 것들을 만들수 있다.(보통 쓰이는 용도는 아님)\r\n\r\n```python\r\nimport types\r\nc=types.CodeType(.......)\r\n```\r\n참고로 저 CodeType의 인자는 12개다.\r\n\r\n##import copy\r\n말 그대로 카피를 위한 모듈.\r\n\r\n다음 예를 보면 어떻게 쓰이는지 알 수 있다.\r\n\r\n```python\r\nimport copy\r\na=[[1,2,3],4,5,6]\r\nb=a #a와 b는 id가 같음\r\nb[1]+=1\r\nprint a#[[1, 2, 3], 5, 5, 6]\r\nprint b#[[1, 2, 3], 5, 5, 6]\r\n\r\nb=copy.copy(a)#a와 b는 id가 다름. 그리고 a[0]과 b[0]의 id는 같음\r\nb[1]+=1\r\nb[0][1]+=1\r\nprint a#[[1, 3, 3], 5, 5, 6] \r\nprint b#[[1, 3, 3], 6, 5, 6]\r\n\r\nb=copy.deepcopy(a)#a와 b는 id가 다름. 그리고 a[0]과 b[0]의 id도 다름\r\nb[1]+=1\r\nb[0][1]+=1\r\nprint a#[[1, 3, 3], 5, 5, 6]\r\nprint b#[[1, 4, 3], 6, 5, 6]\r\n```\r\n\r\n그냥 잘 모르겠으면 deepcopy쓰자\r\n\r\n##import pprint\r\n개발할때 2차원 리스트 출력용으로 편하다.\r\n\r\n\r\npprint.pprint(object, stream=None, indent=1, width=80, depth=None)\r\n\r\n이런식의 함수인데 대부분의 경우 그냥 출력할거 하나만 인자로 넘겨줘도 이쁘게 출력되고, 만약 가로로 짧고 길게 출력이 된다면 width의 값을 적당하게 조절하면된다.(300이라든가 500이라든가)\r\n\r\n```python\r\nfrom pprint import pprint\r\na=[[0 for x in range(10)] for x in range(10)]\r\nprint a\r\npprint(a)\r\n```\r\nprint는\r\n```\r\n[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\r\n```\r\n이렇게 뜨지만, pprint 는\r\n```\r\n[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\r\n```\r\n겁나 이쁘게 뜬다.\r\n\r\n#수학관련 모듈들\r\n\r\n##import math\r\n수학과 관련된 모듈. 특이하게 이건 built-in으로 임포트된다. 설명에도 이 모듈은 항상 사용가능하다고 되어있다.\r\n\r\n이건 설명의 필요성을 딱히 못느껴서 생략\r\n\r\n##import cmath\r\nc로 짜여져있어서 cmath가 아니라 complex의 cmath다.\r\n\r\n이것역시 설명의 필요성을 딱히 못느껴서 생략\r\n\r\n##from decimal import \\*\r\n좀더 정확한 부동소수점 사용을 위한 모듈\r\n\r\n특이하게 파이썬사이트에도 from decimal import \\* 로 나와있다.\r\n\r\n이건 너무 수학적인거라 간단한것만 소개하고 생략\r\n\r\n```python\r\nfrom decimal import \\*\r\ngetcontext().prec = 28 #정확도를 소수점28자리까지\r\nprint Decimal(1)/Decimal('7')\r\n```\r\n주의할점은 Decimal(v)의 v부분에 int,float,string 이 들어갈수 있지만 float의 경우 오차가 발생해서 들어간다는 점이다.\r\n```\r\nDecimal(1.1)#Decimal('1.100000000000000088817841970012523233890533447265625')\r\nDecimal('1.1')#Decimal('1.1')\r\n```\r\n\r\n[여길](https://docs.python.org/2/library/decimal.html) 참고하자.\r\n\r\n##import random\r\n랜덤과 관련된 함수.\r\n\r\n선언하는 순간 os.urandom이나 현재 시각을 seed로 한번 초기화를 하니, 따로 random.seed로 초기화해줄 필요는 없다.\r\n\r\n알아두어야 할 점은, 이 랜덤모듈은 진짜 랜덤하지 않다는 것과, 순서가 정해져 있다는것이다.\r\n\r\n```python\r\nrandom.seed(1)\r\nrandom.random()#0.13436424411240122\r\nrandom.random()#0.8474337369372327\r\nrandom.random()#0.763774618976614\r\nrandom.seed(1)\r\nrandom.random()#0.13436424411240122\r\nrandom.random()#0.8474337369372327\r\nrandom.random()#0.763774618976614\r\n```\r\n이걸 피하고싶으면 os.urandom을 의사난수로 사용하는 랜덤클래스를 만들어서 쓰면된다\r\n```python\r\nsecure_random=random.SystemRandom()\r\n```\r\n\r\n- random.randrange(start,stop[,step])\r\n\r\n =random.choice(range(start,stop[,step])\r\n\r\n- random.randint(x,y)\r\n\r\n x이상 y이하의 랜덤한 정수 리턴\r\n \r\n- random.choice(seq)\r\n\r\n seq에서 랜덤한 하나 뽑음\r\n \r\n- random.shuffle(x)\r\n\r\n x를 섞는다. 리턴값이 없는게 특징(리스트를 넘기고 print해보면 섞여있음)\r\n \r\n- random.sample(x,k)\r\n\r\n x에서 k개를 랜덤하게 뽑아 리스트로 리턴\r\n \r\n- random.random()\r\n\r\n 0이상 1미만의 랜덤한 float형을 리턴\r\n \r\n- random.getstate()\r\n\r\n 현재 난수생성기의 상태를 출력한다. setstate의 인자로 쓰임. \r\n \r\n- random.setstate(state)\r\n\r\n state로 현재 난수생성기의 상태를 설정한다. getstate()와 함께 버그재현 디버깅용으로 좋을듯\r\n\r\n- random.seed([x])\r\n\r\n 시드 설정. 인자를 주지 않으면 os.urandom이나 현재 시각을 seed로 사용한다. \r\n \r\n 어차피 모듈로드시 호출되는데, 디버깅용아니면 호출하지 말자.\r\n\r\n그외에 많은것들은 [여길](https://docs.python.org/2/library/random.html) 참고.\r\n\r\n##import itertools\r\n이해하는중\r\n\r\n#파일관련 모듈\r\n\r\n##import os.path\r\n파일관련 모듈\r\n\r\nOS쪽에서 해주는게 많음\r\n\r\n- os.path.exists(path)\r\n\r\n 파일이나 폴더가 존제하는지 체크\r\n \r\n- os.path.getsize(path)\r\n\r\n 파일크기 리턴. 없으면 에러\r\n \r\n- os.path.join(path,\\*paths)\r\n\r\n 여러개의 폴더명들을 합쳐준다.\r\n\r\n ```python\r\n os.path.join('1','2')#'1\\\\2'\r\n ```\r\n 리눅스에선 / 윈도우에선 \\ 로 알아서 넣어주기 때문에 호환성을 생각한다면 이 함수를 쓰는게 좋다.\r\n \r\n- os.path.normpath(path)\r\n\r\n 이함수는 path를 받아서 normalize해준다. 대충 이런식\r\n ```python\r\n os.path.normpath('test/./test2')#test/test2\r\n os.path.normpath('test/foo/../test2')#test/test2\r\n ```\r\n 신기해서 언급하긴 했는데... 보안상 매우 안좋은 함수인듯\r\n \r\n\r\n##import fileinput\r\n어떻게 쓰는건지를 모르겠다\r\n\r\n##import tempfile\r\n- tempfile.mktemp()\r\n\r\n 보안상의 이유로 __쓰지 말자__\r\n \r\n tempfile.mkstemp를 쓰자\r\n \r\n\r\n- tempfile.mkstemp([suffix=''[, prefix='tmp'[, dir=None[, text=False]]]])\r\n\r\n 안전한 tmp파일 만드는 함수이다. 설명에 의하면 가장 안전하다고 한다. 레이스 컨디션도 막아주는 모양\r\n \r\n 리턴값이 특이한데 (파일 디스크립터 넘버,tmp파일 경로) 이렇게 리턴한다.\r\n \r\n 구글링해봐도 다들 조금씩 사용법이 틀린데 내 맘에든것은 이것\r\n \r\n ```python\r\n import os,tempfile\r\n fd,path=tempfile.mkstemp()\r\n os.write(fd,'something')\r\n os.close(fd)\r\n os.remove(path)\r\n ```\r\n 또는\r\n ```python\r\n import os,tempfile\r\n fd,path=tempfile.mkstemp()\r\n f=os.fdopen(fd,'w')\r\n f.write('something')\r\n f.close\r\n os.remove(path)\r\n ```\r\n 그냥 tempfile.TemporaryFile 쓰는게 속편할것같다.\r\n \r\n- tempfile.TemporaryFile([mode='w+b'[, bufsize=-1[, suffix=''[, prefix='tmp'[, dir=None]]]]])\r\n\r\n 파일처럼 쓸 수 있는 객체를 리턴한다.\r\n \r\n 옵션도 있을꺼 다있고 그냥 이거쓰면 될듯\r\n \r\n ```python\r\n f=tempfile.TemporaryFile()\r\n f.write('adsf')\r\n f.close()#이순간 파일 삭제\r\n ```\r\n찾아보니 이함수가 내부적으로 mkstemp()쓴다고 한다.\r\n\r\n##import glob\r\n파일리스트 얻는데에는 이 모듈보다 좋은게 없다. 예제를 보자\r\n```python\r\nimport glob\r\nprint glob.glob('*.exe')\r\n```\r\n하면 ['file1.exe','file2.exe']이런식으로 리스트를 리턴한다.\r\n\r\n참고로 \\* 말고도 왠만한 정규식은 되는 모양.\r\n\r\nglob대신 iglob로 호출하면 리스트대신 iterator를 리턴함\r\n\r\n\r\n##import shutil\r\n파일관련 고수준(high-level) 함수를 제공하는 모듈이다. 압축도 해줌.\r\n\r\n쓰기귀찮으니 다음기회에\r\n\r\n\r\n#데이터 관련 모듈\r\n\r\n##import pickle\r\n \r\n\r\n\r\n\r\n##end\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}